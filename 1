Racket

	lambda:

		(lambda (x y z ...) (function ...))

		((lambda (x y z ...) (function ...)) 1 2 3 ...) return result

	define:

		(define funName (lambda (x) (fun)))

		(define (funcName x) (fun))

	lst:

		t = '(1 2 3 4 5)

		(first t) = 1
		(last t) = 5
		(rest t) = (2 3 4 5)

	append:

		(append '(1 2 3) '(6 7 8)) => (1 2 3 6 7 8)
		(append '(1 2 3) 1) => (1 2 3 . 1) this is a pair
		(car (append '(1 2 3) 1)) => 1
		(cdr (append '(1 2 3) 1)) => (2 3 . 1)

	pair:

		car:
			(car (1 . 2)) = 1
			(car '(1)) = 1
		cdr:
			(cdr (1 . 2)) = 2
			(cdr '(1)) = ()

	< > <= >=:
	 	(< x y) ==> x<y

	map:
		(map procesure lst...) => do pro for each lst

		(map + '(1 2 3) '( 2 3 4)) ==> '(3 5 7)

		(map (lambda (x y) (+ 1 x y)) '(1 2 3) '( 2 3 4)) ==> '(4 6 8)

	apply:
		(apply op lst)
		(apply + '(1 2 3)) ==> 6

	fold:
		(foldr op id lst)
		(foldr op id â€™(e1 e2 ... en)) => (op e1 (op e2 (op ... (op en id))))

	cons:
		(cons 1 2) ==> (1 . 2)
		(cons '(1 2 3) 4) ==> ((1 2 3) . 4)
		(cons '(1 2 3) '(2 3 4)) ==> ((1 2 3) 2 3 4)
		(cons 2 '(2 3 4)) ==> (2 2 3 4) list


Python:
	
	zip:
		list(zip([1,2,3],[7,8,9])) = []

	map and lambda:
		map(lambda x, y: x*y, vector1, vector2)

	reduce:
		 reduce(function, iterable[, initializer])
		 reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) ==> ((((1+2)+3)+4)+5)
	
		 reduce(lambda x, y: x+y, [1, 2, 3, 4, 5],8) ==> (((((8 + 1)+2)+3)+4)+5)

	list compressi:

		
		[vector_add1(x, y) for x, y in zip(matrix1, matrix2)]






































